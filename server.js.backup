// Enhanced Level Up Backend Server with Existing Supabase Auth Table
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { createClient } = require('@supabase/supabase-js');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { body, validationResult } = require('express-validator');
const { randomUUID } = require('crypto');

const app = express();
const PORT = process.env.PORT || 8000;

// Initialize Supabase client
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_KEY,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  }
);

// Middleware
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
app.use(express.json());

// Authentication middleware
const authenticateToken = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Get fresh user data from auth.users table
    const { data: user, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', decoded.userId)
      .single();

    if (error || !user) {
      return res.status(401).json({ error: 'Invalid token' });
    }

    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};

// Role-based access control
const requireRole = (allowedRoles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    next();
  };
};

// ===============================
// AUTHENTICATION ROUTES
// ===============================

// User Registration (works with existing table structure)
app.post('/api/auth/register', [
  body('email').isEmail().withMessage('Valid email required'),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters'),
  body('name').notEmpty().withMessage('Name is required'),
  body('role').isIn(['student', 'educator', 'parent', 'operation_manager', 'admin']).withMessage('Valid role required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { email, password, name, role, ...roleSpecificData } = req.body;

    // Check if user already exists
    const { data: existingUser } = await supabase
      .from('users')
      .select('id')
      .eq('email', email)
      .single();

    if (existingUser) {
      return res.status(400).json({ error: 'User already exists with this email' });
    }

    // Hash password (using same method as Supabase for compatibility)
    const saltRounds = 12;
    const hashedPassword = await bcrypt.hash(password, saltRounds);

    // Generate UUID for the user (Supabase uses UUIDs)
    const userId = randomUUID();

    // Prepare user data based on existing table structure
    const userData = {
      id: userId,
      email,
      encrypted_password: hashedPassword, // Using Supabase's column name
      name,
      role,
      is_active: true,
      joined_date: new Date().toISOString(),
      last_login: new Date().toISOString(),
      total_tests: 0,
      average_score: 0.0,
      best_score: 0,
      current_streak: 0,
      total_study_hours: 0.0,
      notification_preferences: {}
    };

    // Add role-specific data
    if (role === 'student') {
      userData.target_nlu = roleSpecificData.targetNLU;
      userData.target_score = roleSpecificData.targetScore;
      userData.preparation_stage = roleSpecificData.preparationStage;
      userData.study_hours_per_week = roleSpecificData.studyHours;
    } else if (role === 'educator') {
      userData.institute_id = roleSpecificData.instituteId;
      userData.subjects = roleSpecificData.subjects;
      userData.verification_status = 'pending';
    }

    // Create user in database
    const { data: newUser, error } = await supabase
      .from('users')
      .insert([userData])
      .select('id, name, email, role, target_nlu, target_score, institute_id, verification_status, joined_date')
      .single();

    if (error) {
      console.error('Full error details:', JSON.stringify(error, null, 2));    console.error('Error message:', error.message);    console.error('Error code:', error.code);    console.error('Error details:', error.details);
      return res.status(500).json({ error: 'Failed to create user' });
    }

    // Generate JWT token
    const token = jwt.sign(
      { userId: newUser.id, email: newUser.email, role: newUser.role },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );

    console.log(`âœ… New ${role} registered:`, newUser.email);

    res.status(201).json({
      message: 'User registered successfully',
      token,
      user: newUser
    });

  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Server error during registration' });
  }
});

// User Login (works with existing table structure)
app.post('/api/auth/login', [
  body('email').isEmail().withMessage('Valid email required'),
  body('password').notEmpty().withMessage('Password is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { email, password } = req.body;

    // Find user by email
    const { data: user, error } = await supabase
      .from('users')
      .select('*')
      .eq('email', email)
      .single();

    if (error || !user) {
      return res.status(400).json({ error: 'Invalid email or password' });
    }

    // Verify password (works with encrypted_password column)
    const isPasswordValid = await bcrypt.compare(password, user.encrypted_password);
    if (!isPasswordValid) {
      return res.status(400).json({ error: 'Invalid email or password' });
    }

    // Update last login
    await supabase
      .from('users')
      .update({ last_login: new Date().toISOString() })
      .eq('id', user.id);

    // Generate JWT token
    const token = jwt.sign(
      { userId: user.id, email: user.email, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );

    console.log(`âœ… ${user.role} logged in:`, user.email);

    // Remove sensitive data from response
    const { encrypted_password, confirmation_token, recovery_token, ...userResponse } = user;

    res.json({
      message: 'Login successful',
      token,
      user: userResponse
    });

  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Server error during login' });
  }
});

// Get Current User
app.get('/api/auth/me', authenticateToken, async (req, res) => {
  try {
    const { encrypted_password, confirmation_token, recovery_token, ...userResponse } = req.user;
    res.json({ user: userResponse });
  } catch (error) {
    console.error('Auth error:', error);
    res.status(401).json({ error: 'Invalid token' });
  }
});

// Logout
app.post('/api/auth/logout', authenticateToken, async (req, res) => {
  try {
    console.log(`âœ… ${req.user.role} logged out:`, req.user.email);
    res.json({ message: 'Logged out successfully' });
  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({ error: 'Logout failed' });
  }
});

// ===============================
// ANALYTICS ROUTES (USING EXISTING COLUMNS)
// ===============================

// Get user dashboard analytics (uses existing columns)
app.get('/api/analytics/dashboard', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const userRole = req.user.role;

    let analytics;
    
    if (userRole === 'student') {
      // Use existing columns from the user table
      analytics = {
        mockTestsTaken: req.user.total_tests || 0,
        averageScore: Math.round(req.user.average_score || 0),
        bestScore: req.user.best_score || 0,
        currentStreak: req.user.current_streak || 0,
        improvement: 0, // Will calculate from historical data later
        targetProgress: req.user.target_score ? Math.round((req.user.average_score / req.user.target_score) * 100) : 0,
        studyHours: req.user.total_study_hours || 0
      };
    } else if (userRole === 'educator') {
      analytics = {
        totalStudents: 0, // Will query assigned students
        averageClassScore: 0,
        topPerformer: null,
        weakAreas: [],
        improvementRate: 0
      };
    } else if (userRole === 'parent') {
      analytics = {
        childrenCount: req.user.children_ids ? req.user.children_ids.length : 0,
        overallProgress: 0,
        lastTestScore: 0,
        studyHoursThisWeek: 0
      };
    } else if (userRole === 'operation_manager') {
      analytics = {
        totalUsers: 0,
        activeStudents: 0,
        revenueThisMonth: 0,
        userGrowthRate: 0
      };
    } else if (userRole === 'admin') {
      analytics = {
        totalPlatformUsers: 0,
        institutesCount: 0,
        systemHealth: 100,
        dailyActiveUsers: 0
      };
    }

    console.log(`ğŸ“Š ${userRole} analytics for user:`, userId);
    res.json(analytics);
    
  } catch (error) {
    console.error('Error fetching analytics:', error);
    res.status(500).json({ error: 'Failed to fetch analytics' });
  }
});

// ===============================
// MOCK TEST ROUTES
// ===============================

// Submit mock test result (updates existing user columns)
app.post('/api/mock-tests/:id/submit', authenticateToken, requireRole(['student']), async (req, res) => {
  try {
    const { id } = req.params;
    const { score, total_questions } = req.body;
    const userId = req.user.id;
    
    // Update user statistics in the users table
    const currentTests = req.user.total_tests || 0;
    const currentAverage = req.user.average_score || 0;
    const newAverage = ((currentAverage * currentTests) + score) / (currentTests + 1);
    const newBestScore = Math.max(req.user.best_score || 0, score);
    
    const { error: updateError } = await supabase
      .from('users')
      .update({
        total_tests: currentTests + 1,
        average_score: newAverage,
        best_score: newBestScore,
        last_login: new Date().toISOString()
      })
      .eq('id', userId);

    if (updateError) {
      console.error('Error updating user stats:', updateError);
    }

    console.log('ğŸ“ Mock test submission:', { userId, score, newAverage });
    
    const result = {
      id: Date.now(),
      user_id: userId,
      mock_test_id: id,
      score,
      submitted_at: new Date().toISOString(),
      message: 'Test submitted successfully'
    };

    res.json(result);
  } catch (error) {
    console.error('Error submitting mock test:', error);
    res.status(500).json({ error: 'Failed to submit mock test' });
  }
});

// ===============================
// USER MANAGEMENT ROUTES
// ===============================

// Get all users (admin and operation_manager only)
app.get('/api/users', authenticateToken, requireRole(['admin', 'operation_manager']), async (req, res) => {
  try {
    const { data: users, error } = await supabase
      .from('users')
      .select('id, name, email, role, joined_date, is_active, total_tests, average_score')
      .order('joined_date', { ascending: false });

    if (error) throw error;

    console.log(`ğŸ‘¥ User list requested by ${req.user.role}:`, req.user.email);
    res.json(users);
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// ===============================
// HEALTH CHECK ROUTE
// ===============================

app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    supabase: 'Connected',
    version: '2.0.0',
    features: ['existing-auth-table', 'multi-role-auth', 'analytics', 'user-management']
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`ğŸš€ Level Up Backend Server running on port ${PORT}`);
  console.log(`ğŸ“Š Supabase URL: ${process.env.SUPABASE_URL}`);
  console.log(`ğŸ” Frontend URL: ${process.env.FRONTEND_URL}`);
  console.log(`ğŸ‘¥ Multi-role authentication enabled (existing table)`);
  console.log(`ğŸŒŸ Ready to serve all user types!`);
});
